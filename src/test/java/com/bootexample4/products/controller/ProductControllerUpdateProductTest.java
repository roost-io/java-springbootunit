
// ********RoostGPT********
/*
Test generated by RoostGPT for test dbrx-java using AI Type DBRX and AI Model mixtral-8x7b-instruct-v0.1
ROOST_METHOD_HASH=updateProduct_850f4057dd
ROOST_METHOD_SIG_HASH=updateProduct_7d978906b6
1. Scenario 1: Test updating a valid product with existing id
TestName: testUpdateValidProduct()
Details:
This test checks the successful update of a product with a valid id present in the repository.
Execution:
Arrange: Create a valid Product object and an existing id.
Act: Invoke the target method with the valid id and Product object.
Assert: Assert that the method returns ResponseEntity.ok() and updated product details are returned.
Validation:
Assertion verifies if the updateProduct method is able to successfully update a product with existing id.
2. Scenario 2: Test updating a product with non-existing id
TestName: testUpdateProductWithNonExistingId()
Details:
This test checks if the method returns ResponseEntity.notFound() when the id provided does not exist in the repository.
Execution:
Arrange: Create a valid Product object and a non-existing id.
Act: Invoke the target method with the non-existing id and Product object.
Assert: Assert that the method returns ResponseEntity.notFound().
Validation:
Assertion verifies if the updateProduct method correctly handles cases where the provided id does not exist in the repository.
3. Scenario 3: Test updating a product with empty or null fields
TestName: testUpdateProductWithEmptyFields()
Details:
This test checks if the method sets the fields of the existing product to null or empty string when the corresponding incoming fields are null or empty.
Execution:
Arrange: Create a valid Product object with empty or null fields, and an existing id.
Act: Invoke the target method with the existing id and Product object.
Assert: Assert that the method returns ResponseEntity.ok() and the existing product fields are updated with the incoming fields, including empty or null values.
Validation:
Assertion verifies if the updateProduct method correctly handles cases where the incoming product fields are empty or null.
4. Scenario 4: Test updating a product with negative price
TestName: testUpdateProductWithNegativePrice()
Details:
This test checks if the method correctly handles the case when the incoming product price is negative.
Execution:
Arrange: Create a valid Product object with a negative price, and an existing id.
Act: Invoke the target method with the existing id and Product object.
Assert: Assert that the method returns ResponseEntity.ok() and the existing product price is set to 0 or a default value.
Validation:
Assertion verifies if the updateProduct method handles cases where the incoming product price is negative.
5. Scenario 5: Test updating a product with a null object
TestName: testUpdateProductWithNullProductObject()
Details:
This test checks if the method returns ResponseEntity.notFound() when the incoming Product object is null.
Execution:
Arrange: Create a null Product object and an existing id.
Act: Invoke the target method with the existing id and null Product object.
Assert: Assert that the method returns ResponseEntity.notFound().
Validation:
Assertion verifies if the updateProduct method correctly handles cases where the incoming Product object is null.
*/
// ********RoostGPT********
package com.bootexample4.products.controller;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;
import java.util.Optional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.http.ResponseEntity;
import static org.junit.jupiter.api.Assertions.*;
import java.util.List;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import com.bootexample4.products.model.Product;
import com.bootexample4.products.repository.ProductRepository;
import org.junit.jupiter.api.*;

@Tag("com.bootexample4.products.model")
@Tag("com.bootexample4.products.model.setName")
@Tag("com.bootexample4.products.model.getName")
@Tag("com.bootexample4.products.model.setDescription")
@Tag("com.bootexample4.products.model.getDescription")
@Tag("com.bootexample4.products.model.setPrice")
@Tag("com.bootexample4.products.model.getPrice")
@Tag("com.bootexample4.products.controller")
@Tag("com.bootexample4.products.controller.updateProduct")
class ProductControllerUpdateProductTest {
private ProductController productController;
private ProductRepository productRepository;
@BeforeEach
void setUp() {
productRepository = mock(ProductRepository.class);
productController = new ProductController(productRepository);
}
@Test
void testUpdateValidProduct() {
// Arrange
Product existingProduct = new Product();
existingProduct.setId(1L);
existingProduct.setName("Existing Product");
existingProduct.setDescription("This is an existing product.");
existingProduct.setPrice(10.0);
Product updateProduct = new Product();
updateProduct.setId(1L);
updateProduct.setName("Updated Product");
updateProduct.setDescription("This is an updated product.");
updateProduct.setPrice(15.0);
when(productRepository.findById(1L)).thenReturn(Optional.of(existingProduct));
// Act
ResponseEntity<Product> response = productController.updateProduct(1L, updateProduct);
// Assert
assertEquals(ResponseEntity.ok().body(existingProduct), response);
assertEquals("Updated Product", existingProduct.getName());
assertEquals("This is an updated product.", existingProduct.getDescription());
assertEquals(15.0, existingProduct.getPrice());
}
@Test
void testUpdateProductWithNonExistingId() {
// Arrange
Product updateProduct = new Product();
updateProduct.setId(2L);
updateProduct.setName("Updated Product");
updateProduct.setDescription("This is an updated product.");
updateProduct.setPrice(15.0);
when(productRepository.findById(2L)).thenReturn(Optional.empty());
// Act
ResponseEntity<Product> response = productController.updateProduct(2L, updateProduct);
// Assert
assertEquals(ResponseEntity.notFound().build(), response);
}
@Test
void testUpdateProductWithEmptyFields() {
// Arrange
Product existingProduct = new Product();
existingProduct.setId(1L);
existingProduct.setName("Existing Product");
existingProduct.setDescription("This is an existing product.");
existingProduct.setPrice(10.0);
Product updateProduct = new Product();
updateProduct.setId(1L);
updateProduct.setName("");
updateProduct.setDescription(null);
updateProduct.setPrice(-1.0);
when(productRepository.findById(1L)).thenReturn(Optional.of(existingProduct));
// Act
ResponseEntity<Product> response = productController.updateProduct(1L, updateProduct);
// Assert
assertEquals(ResponseEntity.ok().body(existingProduct), response);
assertEquals("", existingProduct.getName());
assertEquals(null, existingProduct.getDescription());
assertEquals(0.0, existingProduct.getPrice());
}
@Test
void testUpdateProductWithNegativePrice() {
// Arrange
Product existingProduct = new Product();
existingProduct.setId(1L);
existingProduct.setName("Existing Product");
existingProduct.setDescription("This is an existing product.");
existingProduct.setPrice(10.0);
Product updateProduct = new Product();
updateProduct.setId(1L);
updateProduct.setName("Updated Product");
updateProduct.setDescription("This is an updated product.");
updateProduct.setPrice(-5.0);
when(productRepository.findById(1L)).thenReturn(Optional.of(existingProduct));
// Act
ResponseEntity<Product> response = productController.updateProduct(1L, updateProduct);
// Assert
assertEquals(ResponseEntity.ok().body(existingProduct), response);
assertEquals(0.0, existingProduct.getPrice());
}
@Test
void testUpdateProductWithNullProductObject() {
// Arrange
when(productRepository.findById(1L)).thenReturn(Optional.empty());
// Act
ResponseEntity<Product> response = productController.updateProduct(1L, null);
// Assert
assertEquals(ResponseEntity.notFound().build(), response);
}
}